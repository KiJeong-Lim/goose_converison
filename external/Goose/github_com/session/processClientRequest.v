(* autogenerated from command-line-arguments *)
From Perennial.goose_lang Require Import prelude.

Section code.
Context `{ext_ty: ext_types}.

Definition Operation := struct.decl [
  "OperationType" :: uint64T;
  "VersionVector" :: slice.T uint64T;
  "Data" :: uint64T
].

Definition Request := struct.decl [
  "RequestType" :: uint64T;
  "Client_OperationType" :: uint64T;
  "Client_SessionType" :: uint64T;
  "Client_Data" :: uint64T;
  "Client_Vector" :: slice.T uint64T;
  "Receive_Gossip_ServerId" :: uint64T;
  "Receive_Gossip_Operations" :: slice.T (struct.t Operation);
  "Acknowledge_Gossip_ServerId" :: uint64T;
  "Acknowledge_Gossip_Index" :: uint64T;
  "Receiver_ServerId" :: uint64T
].

Definition Reply := struct.decl [
  "ReplyType" :: uint64T;
  "Client_Succeeded" :: boolT;
  "Client_OperationType" :: uint64T;
  "Client_Data" :: uint64T;
  "Client_Vector" :: slice.T uint64T
].

Definition Server := struct.decl [
  "Id" :: uint64T;
  "NumberOfServers" :: uint64T;
  "VectorClock" :: slice.T uint64T;
  "OperationsPerformed" :: slice.T (struct.t Operation);
  "MyOperations" :: slice.T (struct.t Operation);
  "PendingOperations" :: slice.T (struct.t Operation);
  "Data" :: uint64T;
  "GossipAcknowledgements" :: slice.T uint64T
].

Definition compareVersionVector: val :=
  rec: "compareVersionVector" "v1" "v2" :=
    let: "output" := ref_to boolT #true in
    let: "i" := ref_to uint64T #0 in
    let: "l" := ref_to uint64T (slice.len "v1") in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "l")); (λ: <>, Skip) := λ: <>,
      (if: (SliceGet uint64T "v1" (![uint64T] "i")) < (SliceGet uint64T "v2" (![uint64T] "i"))
      then
        "output" <-[boolT] #false;;
        Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue));;
    ![boolT] "output".

Definition maxTwoInts: val :=
  rec: "maxTwoInts" "x" "y" :=
    (if: "x" > "y"
    then "x"
    else "y").

Definition maxTS: val :=
  rec: "maxTS" "t1" "t2" :=
    let: "i" := ref_to uint64T #0 in
    let: "length" := ref_to uint64T (slice.len "t1") in
    let: "output" := ref_to (slice.T uint64T) (NewSlice uint64T (slice.len "t1")) in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "length")); (λ: <>, Skip) := λ: <>,
      SliceSet uint64T (![slice.T uint64T] "output") (![uint64T] "i") (maxTwoInts (SliceGet uint64T "t1" (![uint64T] "i")) (SliceGet uint64T "t2" (![uint64T] "i")));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    ![slice.T uint64T] "output".

Definition dependencyCheck: val :=
  rec: "dependencyCheck" "TS" "request" :=
    compareVersionVector "TS" (struct.get Request "Client_Vector" "request").

Definition processClientRequest: val :=
  rec: "processClientRequest" "server" "request" :=
    let: "reply" := struct.mk Reply [
    ] in
    (if: (~ (dependencyCheck (struct.get Server "VectorClock" "server") "request"))
    then
      struct.storeF Reply "Client_Succeeded" "reply" #false;;
      ("server", "reply")
    else
      (if: (struct.get Request "Client_OperationType" "request") = #0
      then
        struct.storeF Reply "Client_Succeeded" "reply" #true;;
        struct.storeF Reply "Client_OperationType" "reply" #0;;
        struct.storeF Reply "Client_Data" "reply" (struct.get Server "Data" "server");;
        struct.storeF Reply "Client_Vector" "reply" (maxTS (struct.get Request "Client_Vector" "request") (struct.get Server "VectorClock" "server"));;
        ("server", "reply")
      else
        SliceSet uint64T (struct.get Server "VectorClock" "server") (struct.get Server "Id" "server") ((SliceGet uint64T (struct.get Server "VectorClock" "server") (struct.get Server "Id" "server")) + #1);;
        struct.storeF Server "Data" "server" (struct.get Request "Client_Data" "request");;
        let: "op" := struct.mk Operation [
          "OperationType" ::= #1;
          "VersionVector" ::= SliceAppendSlice uint64T slice.nil (struct.get Server "VectorClock" "server");
          "Data" ::= struct.get Server "Data" "server"
        ] in
        struct.storeF Server "OperationsPerformed" "server" (SliceAppend (struct.t Operation) (struct.get Server "OperationsPerformed" "server") "op");;
        struct.storeF Server "MyOperations" "server" (SliceAppend (struct.t Operation) (struct.get Server "MyOperations" "server") "op");;
        struct.storeF Reply "Client_Succeeded" "reply" #true;;
        struct.storeF Reply "Client_OperationType" "reply" #1;;
        struct.storeF Reply "Client_Data" "reply" (struct.get Server "Data" "server");;
        struct.storeF Reply "Client_Vector" "reply" (SliceAppendSlice uint64T slice.nil (struct.get Server "VectorClock" "server"));;
        ("server", "reply"))).

Definition acknowledgeGossip: val :=
  rec: "acknowledgeGossip" "server" "request" :=
    SliceSet uint64T (struct.get Server "GossipAcknowledgements" "server") (struct.get Request "Acknowledge_Gossip_ServerId" "request") (struct.get Request "Acknowledge_Gossip_Index" "request");;
    "server".

Definition getGossipOperations: val :=
  rec: "getGossipOperations" "server" "serverId" :=
    let: "output" := NewSlice (struct.t Operation) #0 in
    SliceAppendSlice (struct.t Operation) "output" (SliceSkip (struct.t Operation) (struct.get Server "MyOperations" "server") (SliceGet uint64T (struct.get Server "GossipAcknowledgements" "server") "serverId")).

End code.
