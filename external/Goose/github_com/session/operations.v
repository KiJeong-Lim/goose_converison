(* autogenerated from command-line-arguments *)
From Perennial.goose_lang Require Import prelude.

Section code.
Context `{ext_ty: ext_types}.

Definition Operation := struct.decl [
  "OperationType" :: uint64T;
  "VersionVector" :: slice.T uint64T;
  "Data" :: uint64T
].

Definition equalSlices: val :=
  rec: "equalSlices" "s1" "s2" :=
    let: "output" := ref_to boolT #true in
    let: "i" := ref_to uint64T #0 in
    let: "l" := ref_to uint64T (slice.len "s1") in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "l")); (λ: <>, Skip) := λ: <>,
      (if: (SliceGet uint64T "s1" (![uint64T] "i")) ≠ (SliceGet uint64T "s2" (![uint64T] "i"))
      then
        "output" <-[boolT] #false;;
        Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue));;
    ![boolT] "output".

Definition equalOperations: val :=
  rec: "equalOperations" "o1" "o2" :=
    (((struct.loadF Operation "OperationType" "o1") = (struct.loadF Operation "OperationType" "o2")) && (equalSlices (struct.loadF Operation "VersionVector" "o1") (struct.loadF Operation "VersionVector" "o2"))) && ((struct.loadF Operation "Data" "o1") = (struct.loadF Operation "Data" "o2")).

Definition deleteAtIndex: val :=
  rec: "deleteAtIndex" "l" "index" :=
    let: "ret" := ref_to (slice.T (struct.t Operation)) (NewSlice (struct.t Operation) #0) in
    "ret" <-[slice.T (struct.t Operation)] (SliceAppendSlice (struct.t Operation) (![slice.T (struct.t Operation)] "ret") (SliceTake "l" "index"));;
    SliceAppendSlice (struct.t Operation) (![slice.T (struct.t Operation)] "ret") (SliceSkip (struct.t Operation) "l" ("index" + #1)).

End code.
